# 功能实现核心代码文档

根据提供的功能列表，以下是各个功能模块的核心实现代码和简要说明。

---

### 5.1.1 城市选择器实现

城市选择器的核心功能包括加载城市数据、根据用户输入过滤城市列表以及处理城市选择。这些功能主要在 [`lib/pages/city_selection_page.dart`](lib/pages/city_selection_page.dart) 文件中实现。

核心代码片段：

1.  **数据加载和初始化**: 在 `initState` 中调用 `_fetchCities` 加载城市数据，并监听搜索框的文本变化。

    ```dart
    // lib/pages/city_selection_page.dart
    // ...
    @override
    void initState() {
      super.initState();
      _citiesFuture = _fetchCities(); // 加载城市数据
      _searchController.addListener(_filterCities); // 监听搜索框变化
    }

    Future<List<file_data.GeneralType>> _fetchCities() async {
      // 加载region.json数据
      await RegionService.loadRegionData();

      // 获取城市列表
      List<file_data.GeneralType> cities = RegionService.getCityList();

      setState(() {
        _allCities = cities;
        _filteredCities = cities;
      });
      return cities;
    }
    // ...
    ```

2.  **城市过滤逻辑**: `_filterCities` 方法根据搜索框的文本过滤城市列表。

    ```dart
    // lib/pages/city_selection_page.dart
    // ...
    void _filterCities() {
      String query = _searchController.text.toLowerCase();
      if (query.isEmpty) {
        setState(() {
          _filteredCities = _allCities;
        });
      } else {
        setState(() {
          _filteredCities = _allCities
              .where((city) => city.name.toLowerCase().contains(query))
              .toList();
        });
      }
    }
    // ...
    ```

3.  **城市列表展示和选择处理**: 使用 `ListView.builder` 展示过滤后的城市列表，并在用户点击城市时更新 `ScopedModel` 中的城市信息并返回。

    ```dart
    // lib/pages/city_selection_page.dart
    // ...
    Expanded(
      child: FutureBuilder<List<file_data.GeneralType>>(
        future: _citiesFuture,
        builder: (context, snapshot) {
          // ... (加载和错误处理)

          return ListView.builder(
            itemCount: _filteredCities.length,
            itemBuilder: (context, index) {
              file_data.GeneralType city = _filteredCities[index];
              return ListTile(
                title: Text(city.name),
                onTap: () {
                  // 更新城市模型
                  ScopedModelHelper.getModel<CityModel>(context).city = city;
                  Navigator.pop(context, city); // 返回选择的城市
                },
              );
            },
          );
        },
      ),
    )
    // ...
    ```

---

### 5.1.2 轮播图、快捷入口、房屋推荐和最新资讯实现

首页的轮播图、快捷入口、房屋推荐和最新资讯等组件在 [`lib/pages/home/tab_index/index.dart`](lib/pages/home/tab_index/index.dart) 中进行整合展示。各个部分的具体实现则分散在不同的文件中。

核心代码片段（[`lib/pages/home/tab_index/index.dart`](lib/pages/home/tab_index/index.dart)）：

```dart
// lib/pages/home/tab_index/index.dart
// ...
class TabIndex extends StatelessWidget {
  const TabIndex({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: Colors.white,
        title: custom.SearchBar( // 搜索栏
          showLocation: true,
          showMap: true,
          inputValue: '',
          onSearch: () {
            Navigator.of(context).pushNamed('search');
          },
          onSearchSubmit: (String value) {
            Navigator.of(context).pushNamed('search', arguments: {'searchWord': value});
          },
        ),
      ),
      body: ListView(
        children: [
          CommonSwiper(), // 轮播图
          IndexNavigator(), // 快捷入口
          IndexRecommand(), // 房屋推荐
          Info(showTitle: true), // 最新资讯
        ],
      ),
    );
  }
}
// ...
```

各个组件的核心实现文件如下：

*   **轮播图**: [`lib/widgets/common_swiper.dart`](lib/widgets/common_swiper.dart)
*   **快捷入口**: [`lib/pages/home/tab_index/index_navigator.dart`](lib/pages/home/tab_index/index_navigator.dart)
*   **房屋推荐**: [`lib/pages/home/tab_index/index_recommand.dart`](lib/pages/home/tab_index/index_recommand.dart)
*   **最新资讯**: [`lib/pages/home/info/index.dart`](lib/pages/home/info/index.dart)

---

### 5.1.3 地图找房实现

地图找房功能主要通过集成 Webview 来加载地图，并与原生代码进行交互，实现定位、房源展示和搜索等功能。核心实现代码位于 [`lib/pages/map_house_page.dart`](lib/pages/map_house_page.dart)。

核心代码片段：

1.  **Webview 初始化与交互**: 初始化 `WebViewController`，设置 JavaScript 模式，加载本地的 `map.html` 文件，并设置 JavaScript Channel 用于与 Web 端通信。

    ```dart
    // lib/pages/map_house_page.dart
    // ...
    late final WebViewController _controller;
    // ...
    Future<void> _initializeWebView() async {
      _controller = WebViewController()
        ..setJavaScriptMode(JavaScriptMode.unrestricted)
        ..setBackgroundColor(const Color(0x00000000))
        ..setNavigationDelegate(
          NavigationDelegate(
            // ... (加载进度和错误处理)
            onPageFinished: (String url) async {
              // 页面加载完成后加载初始数据
              await _loadHouses();
            },
          ),
        )
        ..addJavaScriptChannel(
          'flutter', // JavaScript Channel 名称
          onMessageReceived: (message) {
            _handleWebViewMessage(message.message); // 处理来自 Webview 的消息
          },
        )
        ..loadFlutterAsset('assets/web/map.html'); // 加载本地 HTML 文件
    }
    // ...
    ```

2.  **获取当前位置**: 请求位置权限并获取当前设备的地理位置。

    ```dart
    // lib/pages/map_house_page.dart
    // ...
    Future<void> _requestLocationPermission() async {
      PermissionStatus status = await Permission.location.request();
      if (status.isGranted) {
        _getCurrentLocation();
      } else {
        debugPrint('Location permission denied');
      }
    }

    Future<void> _getCurrentLocation() async {
      try {
        Position position = await Geolocator.getCurrentPosition(
            desiredAccuracy: LocationAccuracy.high);
        _currentCenterLat = position.latitude;
        _currentCenterLon = position.longitude;
        _setMapCenter(_currentCenterLon, _currentCenterLat); // 设置地图中心
      } catch (e) {
        debugPrint('Error getting current location: $e');
      }
    }
    // ...
    ```

3.  **加载房源数据**: 根据当前地图中心点和城市获取房源数据，并更新地图上的标记。

    ```dart
    // lib/pages/map_house_page.dart
    // ...
    Future<void> _loadHouses() async {
      final cityModel = ScopedModelHelper.getModel<CityModel>(context);
      final cityName = cityModel.cityNameOrDefault;

      // 根据当前城市和地图中心点获取房源数据
      _houses = await _houseService.filterByDistanceAndCity(
        _currentCenterLat,
        _currentCenterLon,
        10, // 10km范围内
        cityName, // 添加城市名称作为过滤条件
      );

      _updateMapMarkers(_houses); // 更新地图标记
    }

    void _updateMapMarkers(List<House> houses) {
      final List<Map<String, dynamic>> houseData =
          houses.map((house) => house.toJson()).toList();
      _controller.runJavaScript('updateMarkers(${jsonEncode(houseData)})'); // 调用 Webview 中的 JavaScript 函数更新标记
    }
    // ...
    ```

4.  **处理 Webview 消息**: 处理来自 Webview 的消息，例如地图移动结束时重新加载房源，或点击标记时导航到房源详情页。

    ```dart
    // lib/pages/map_house_page.dart
    // ...
    Future<void> _handleWebViewMessage(String message) async {
      final Map<String, dynamic> messageData = jsonDecode(message);
      final String type = messageData['type'];
      final dynamic data = messageData['data'];

      switch (type) {
        case 'mapMoveEnd':
          _currentCenterLat = data['latitude'];
          _currentCenterLon = data['longitude'];
          _loadHouses(); // 重新加载房源
          break;
        case 'markerClick':
          final String houseId = data['houseId'];
          Navigator.pushNamed(context, '/room/$houseId'); // 导航到房源详情页
          break;
        default:
          debugPrint('Unknown message type: $type');
      }
    }
    // ...
    ```

5.  **城市切换**: 在 AppBar 中点击城市名称，导航到城市选择页面，并在返回后根据新选择的城市更新地图中心和房源。

    ```dart
    // lib/pages/map_house_page.dart
    // ...
    AppBar(
      title: GestureDetector(
        onTap: () async {
          await Navigator.pushNamed(context, 'city_selection');
          // 当用户从城市选择页面返回时，刷新地图
          final newCity = ScopedModelHelper.getModel<CityModel>(context).city;
          if (newCity != null) {
            final coordinates = RegionService.getCoordinatesByCityName(newCity.name);
            if (coordinates != null) {
              _currentCenterLat = coordinates['latitude']!;
              _currentCenterLon = coordinates['longitude']!;
              _setMapCenter(_currentCenterLon, _currentCenterLat);
              _loadHouses(); // 重新加载该区域的房源
            } else {
              debugPrint('Could not find coordinates for city: ${newCity.name}');
            }
          }
        },
        child: Row(
          mainAxisSize: MainAxisSize.min,
          children: [
            Text(cityName),
            const Icon(Icons.arrow_drop_down),
          ],
        ),
      ),
      // ...
    )
    // ...
    ```

---

### 5.2.1 区域筛选和租赁方式筛选实现

区域筛选和租赁方式筛选是房屋搜索功能的重要组成部分，它们与租金范围、户型、朝向、楼层等筛选条件一起，帮助用户精确查找房源。这些筛选条件的实现主要集中在房屋搜索页面 [`lib/pages/home/tab_search/index.dart`](lib/pages/home/tab_search/index.dart) 及其相关的筛选栏组件 [`lib/pages/home/tab_search/filter_bar/index.dart`](lib/pages/home/tab_search/filter_bar/index.dart) 中。

核心代码片段（[`lib/pages/home/tab_search/index.dart`](lib/pages/home/tab_search/index.dart)）：

1.  **筛选条件的应用**: 在 `_fetchRoomsData` 方法中，将当前的筛选参数 `_currentFilterParams` 转换为 API 请求的参数。

    ```dart
    // lib/pages/home/tab_search/index.dart
    // ...
    Future<void> _fetchRoomsData({String? searchWord}) async {
      // ...
      Map<String, dynamic> apiParams = {};

      if (_currentFilterParams != null) {
        apiParams = _currentFilterParams!.toMap(); // 将筛选结果转换为 Map
      }
      // ...
      final response = await DioHttp.of(context).get(
        '/api/rooms',
        apiParams, // 将筛选参数作为 API 请求参数
      );
      // ...
    }
    // ...
    ```

2.  **筛选栏组件**: 在页面的 body 中使用了 `FilterBar` 组件，并通过 `onChange` 回调获取筛选结果。

    ```dart
    // lib/pages/home/tab_search/index.dart
    // ...
    body: Column(
      children: [
        SizedBox(
          height: 41,
          child: FilterBar( // 筛选栏组件
            onChange: (filter_data.FilterBarResult result) {
              setState(() {
                _currentFilterParams = result; // 更新当前的筛选参数
              });
              _fetchRoomsData(searchWord: _currentSearchWord); // 根据新的筛选条件重新获取数据
            },
          ),
        ),
        // ...
      ],
    )
    // ...
    ```

核心代码片段（[`lib/pages/home/tab_search/filter_bar/index.dart`](lib/pages/home/tab_search/filter_bar/index.dart)）：

1.  **区域筛选逻辑**: `_onAreaChange` 方法处理区域筛选的点击事件。它根据当前城市动态加载区域数据，使用 `CommonPicker` 显示区域列表，并将用户的选择更新到 `FilterBarModel`。

    ```dart
    // lib/pages/home/tab_search/filter_bar/index.dart
    // ...
    _onAreaChange(context) {
      final cityModel = ScopedModelHelper.getModel<CityModel>(context);
      final filterModel = ScopedModelHelper.getModel<FilterBarModel>(context);
      String? currentCityNameFromModel = cityModel.city?.name;

      if (currentCityNameFromModel != null && currentCityNameFromModel != '定位中...') {
        // 使用RegionService获取区域数据
        _dynamicAreaOptionsForPicker = RegionService.getDistrictsByCityName(currentCityNameFromModel);
        filterModel.dataList = {...filterModel.dataList, 'districtList': _dynamicAreaOptionsForPicker};
      } else {
        _dynamicAreaOptionsForPicker = [filter_data.GeneralType('不限', 'area_any')];
        filterModel.dataList = {...filterModel.dataList, 'districtList': _dynamicAreaOptionsForPicker};
      }

      if (_dynamicAreaOptionsForPicker.isEmpty) {
          _dynamicAreaOptionsForPicker = [filter_data.GeneralType('不限', 'area_any')];
      }

      int initialIndex = _dynamicAreaOptionsForPicker.indexWhere((item) => item.id == filterModel.selectedDistrictId);
      if (initialIndex == -1) initialIndex = 0;

      setState(() { isAreaActive = true; });

      CommonPicker.showPicker( // 弹出区域选择器
        value: initialIndex,
        context: context,
        options: _dynamicAreaOptionsForPicker.map((item) => item.name).toList(),
      )?.then((index) {
        if (index == null) return;
        if (mounted) {
          String newDistrictId = _dynamicAreaOptionsForPicker[index].id;
          filterModel.selectedDistrictId = newDistrictId; // 更新 FilterBarModel 中的区域ID
          _selectedDistrictIdLocal = newDistrictId;
          _updateTitles(); // 更新筛选栏标题
          _onChange(); // 触发筛选条件变化的事件
        }
      }).whenComplete(() {
        if (mounted) { setState(() { isAreaActive = false; }); }
      });
    }
    // ...
    ```

2.  **租赁方式筛选逻辑**: `_onRentTypeChange` 方法处理租赁方式筛选的点击事件。它使用 `CommonPicker` 显示租赁方式列表，并将用户的选择更新到 `FilterBarModel`。

    ```dart
    // lib/pages/home/tab_search/filter_bar/index.dart
    // ...
    _onRentTypeChange(context) {
      final filterModel = ScopedModelHelper.getModel<FilterBarModel>(context);
      final currentRentTypeList = filterModel.dataList['rentTypeList'] ?? _rentTypeListLocal;

      int initialIndex = currentRentTypeList.indexWhere((item) => item.id == filterModel.selectedRentTypeId);
      if (initialIndex == -1) initialIndex = 0;

      setState(() { isRentTypeActive = true; });

      CommonPicker.showPicker( // 弹出租赁方式选择器
        value: initialIndex,
        context: context,
        options: currentRentTypeList.map((item) => item.name).toList(),
      )?.then((index) {
        if (index == null) return;
        if (mounted) {
          String newRentTypeId = currentRentTypeList[index].id;
          filterModel.selectedRentTypeId = newRentTypeId; // 更新 FilterBarModel 中的租赁方式ID
          _selectedRentTypeIdLocal = newRentTypeId;
          _updateTitles(); // 更新筛选栏标题
          _onChange(); // 触发筛选条件变化的事件
        }
      }).whenComplete(() {
        if (mounted) { setState(() { isRentTypeActive = false; }); }
      });
    }
    // ...
    ```

3.  **FilterBarModel 的作用**: `FilterBarModel` (`lib/scoped_model/room_filter.dart`) 用于集中管理所有筛选条件的状态（包括区域、租赁方式、租金、户型、朝向、楼层等）。`FilterBar` 和 `FilterDrawer` 都通过 `ScopedModelHelper` 访问和修改这个模型，从而实现状态共享和同步。当 `FilterBarModel` 中的筛选条件发生变化时，会通知监听者（例如 `TabSearch` 页面）重新加载房源数据。

---

### 5.2.2 租金范围筛选和户型/朝向/楼层筛选实现

租金范围、户型、朝向和楼层筛选功能主要在房屋搜索页面的侧边抽屉 [`lib/pages/home/tab_search/filter_bar/filter_drawer.dart`](lib/pages/home/tab_search/filter_bar/filter_drawer.dart) 中实现。用户在抽屉中选择这些筛选条件，并通过 `FilterBarModel` 更新状态。

核心代码片段（[`lib/pages/home/tab_search/filter_bar/filter_drawer.dart`](lib/pages/home/tab_search/filter_bar/filter_drawer.dart)）：

1.  **FilterDrawer 结构**: `FilterDrawer` 是一个 `Drawer` 组件，内部包含 `ListView` 来展示不同的筛选选项。

    ```dart
    // lib/pages/home/tab_search/filter_bar/filter_drawer.dart
    // ...
    class FilterDrawer extends StatelessWidget {
      const FilterDrawer({Key? key}) : super(key: key);

      @override
      Widget build(BuildContext context) {
        var model = ScopedModelHelper.getModel<FilterBarModel>(context);
        var dataList = model.dataList;

        var roomTypeList = dataList['roomTypeList'];
        var orientedList = dataList['orientedList'];
        var floorList = dataList['floorList'];

        return Drawer( // 侧边抽屉
          child: SafeArea(
            child: ListView( // 筛选选项列表
              padding: const EdgeInsets.only(bottom: 60.0), // 为底部的按钮留出空间
              children: [
                // ... 其他筛选选项 (区域、方式、价格在 FilterBar 中处理)

                const CommonTitle('户型'), // 户型标题
                if (roomTypeList != null)
                  FilterDrawerItem( // 户型选项列表
                    list: roomTypeList,
                    selectIds: model.selectedRoomTypeList.toList(),
                    onChange: (id) {
                      model.toggleSelectedRoomTypeItem(id); // 更新户型选中状态
                    },
                  ),

                const CommonTitle('朝向'), // 朝向标题
                if (orientedList != null)
                  FilterDrawerItem( // 朝向选项列表
                    list: orientedList,
                    selectIds: model.selectedOrientedList.toList(),
                    onChange: (id) {
                      model.toggleSelectedOrientedItem(id); // 更新朝向选中状态
                    },
                  ),

                const CommonTitle('楼层'), // 楼层标题
                if (floorList != null)
                  FilterDrawerItem( // 楼层选项列表
                    list: floorList,
                    selectIds: model.selectedFloorList.toList(),
                    onChange: (id) {
                      model.toggleSelectedFloorItem(id); // 更新楼层选中状态
                    },
                  ),

                // 清除和确认按钮
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Row(
                    mainAxisAlignment: MainAxisAlignment.spaceBetween,
                    children: [
                      Expanded(
                        child: OutlinedButton(
                          onPressed: () {
                            model.clearSelections(); // 清除所有筛选
                          },
                          child: const Text('清除'),
                        ),
                      ),
                      const SizedBox(width: 10),
                      Expanded(
                        child: ElevatedButton(
                          onPressed: () {
                            var filters = model.getApiFilterParams; // 获取筛选参数
                            print('Selected filters: $filters');
                            Navigator.of(context).pop(); // 关闭抽屉
                            // 抽屉关闭后，FilterBar 中的监听器会触发搜索逻辑
                          },
                          child: const Text('确定'),
                        ),
                      ),
                    ],
                  ),
                )
              ],
            ),
          ),
        );
      }
    }
    // ...
    ```

2.  **FilterDrawerItem 组件**: `FilterDrawerItem` 是一个可重用的组件，用于展示一组筛选选项（如户型列表、朝向列表等）。它接收一个选项列表 `list` 和当前选中的选项 ID 列表 `selectIds`，以及一个 `onChange` 回调函数。

    ```dart
    // lib/pages/home/tab_search/filter_bar/filter_drawer.dart
    // ...
    class FilterDrawerItem extends StatelessWidget {
      final List<GeneralType> list;
      final List<String> selectIds;
      final ValueChanged<String> onChange;

      const FilterDrawerItem(
          {Key? key,
          required this.list,
          required this.selectIds,
          required this.onChange})
          : super(key: key);

      @override
      Widget build(BuildContext context) {
        return Container(
          padding: const EdgeInsets.symmetric(horizontal: 10.0, vertical: 10.0),
          child: Wrap( // 使用 Wrap 布局选项
            spacing: 10,
            runSpacing: 10,
            children: list.map((item) {
              var isActive = selectIds.contains(item.id); // 判断当前选项是否被选中

              return GestureDetector(
                onTap: () {
                  onChange(item.id); // 点击时调用 onChange 回调
                },
                behavior: HitTestBehavior.translucent,
                child: Container( // 选项的 UI
                  width: (MediaQuery.of(context).size.width - 40 - 20) / 3,
                  height: 40,
                  decoration: BoxDecoration(
                      color: isActive ? Theme.of(context).primaryColor : Colors.grey[200],
                      border: Border.all(
                        width: 1,
                        color: isActive ? Theme.of(context).primaryColor : Colors.grey[400]!
                      ),
                      borderRadius: BorderRadius.circular(4.0)
                  ),
                  child: Center(
                    child: Text(
                      item.name,
                      textAlign: TextAlign.center,
                      style: TextStyle(
                          color: isActive ? Colors.white : Colors.black87,
                          fontSize: 14.0
                      ),
                    ),
                  ),
                ),
              );
            }).toList(),
          ),
        );
      }
    }
    // ...
    ```

3.  **FilterBarModel 的更新**: 在 `FilterDrawerItem` 的 `onTap` 回调中，通过调用 `FilterBarModel` 的相应方法（如 `toggleSelectedRoomTypeItem`）来更新选中状态。`FilterBarModel` 会管理这些选中状态，并在用户点击“确定”按钮关闭抽屉后，通知监听者（`TabSearch`）执行搜索。

---

### 5.2.3 关键词搜索功能实现

关键词搜索功能主要通过搜索栏组件 [`lib/widgets/search_bar/index.dart`](lib/widgets/search_bar/index.dart) 和房屋搜索页面 [`lib/pages/home/tab_search/index.dart`](lib/pages/home/tab_search/index.dart) 的配合来实现。用户在搜索栏输入关键词并提交后，房屋搜索页面会根据关键词重新加载房源数据。

核心代码片段（[`lib/widgets/search_bar/index.dart`](lib/widgets/search_bar/index.dart)）：

1.  **搜索框输入与提交**: `SearchBar` 组件包含一个 `TextField` 用于用户输入关键词。通过 `onChanged` 监听输入变化，通过 `onSubmitted` 监听用户点击键盘搜索按钮的事件。

    ```dart
    // lib/widgets/search_bar/index.dart
    // ...
    Expanded(
      child: Container(
        // ...
        child: TextField(
          controller: _controller, // 控制文本
          focusNode: _focus, // 控制焦点
          onTap: () {
            if (widget.onSearch != null) {
              widget.onSearch!(); // 点击搜索框触发的回调
            } else if (widget.onSearchSubmit != null) {
              FocusScope.of(context).requestFocus(_focus);
            } else {
              _focus.unfocus();
            }
          },
          onSubmitted: (String value) { // 监听键盘搜索按钮提交
            if (widget.onSearchSubmit != null) {
              widget.onSearchSubmit!(value); // 触发搜索提交回调
            }
          },
          textInputAction: TextInputAction.search, // 键盘回车显示为搜索
          onChanged: (value) { // 监听文本变化
            setState(() => _searchWord = value);
          },
          // ...
        ),
      ),
    )
    // ...
    ```

2.  **搜索提交回调**: `SearchBar` 通过 `onSearchSubmit` 参数提供一个回调函数，当用户提交搜索时，会将输入的关键词作为参数传递出去。

    ```dart
    // lib/widgets/search_bar/index.dart
    // ...
    final ValueChanged<String>? onSearchSubmit; // 点击回车触发的回调
    // ...
    ```

核心代码片段（[`lib/pages/home/tab_search/index.dart`](lib/pages/home/tab_search/index.dart)）：

1.  **接收搜索关键词**: `TabSearch` 页面在构建 `SearchBar` 时，通过 `onSearchSubmit` 回调接收关键词。

    ```dart
    // lib/pages/home/tab_search/index.dart
    // ...
    AppBar(
      // ...
      title: custom.SearchBar(
        // ...
        onSearchSubmit: (String value) { // 接收搜索关键词
          setState(() {
            _currentSearchWord = value; // 更新当前搜索词状态
          });
          _fetchRoomsData(searchWord: value); // 使用新搜索词获取数据
        },
      ),
    ),
    // ...
    ```

2.  **根据关键词获取房源**: 在 `_fetchRoomsData` 方法中，将接收到的搜索关键词添加到 API 请求参数中。

    ```dart
    // lib/pages/home/tab_search/index.dart
    // ...
    Future<void> _fetchRoomsData({String? searchWord}) async {
      // ...
      Map<String, dynamic> apiParams = {};

      if (_currentFilterParams != null) {
        apiParams = _currentFilterParams!.toMap();
      }

      // 添加搜索词到 API 参数
      if (searchWord != null && searchWord.isNotEmpty) {
        apiParams['q'] = searchWord; // 将搜索词添加到参数中 (假设后端使用 'q')
      }
      // ...
      final response = await DioHttp.of(context).get(
        '/api/rooms',
        apiParams, // 包含搜索词的 API 参数
      );
      // ...
    }
    // ...
    ```

通过这种方式，用户在搜索栏输入的关键词会被传递到房屋搜索页面，并作为参数用于请求过滤后的房源数据。

---

### 5.3.1 资讯列表展示实现

资讯列表展示功能主要在 [`lib/pages/home/info/index.dart`](lib/pages/home/info/index.dart) 文件中实现。它负责从后端获取资讯数据，并在 UI 上进行展示。

核心代码片段（[`lib/pages/home/info/index.dart`](lib/pages/home/info/index.dart)）：

1.  **获取资讯数据**: 在 `initState` 中调用 `_fetchNewsData` 方法，通过 `DioHttp` 发送 GET 请求到 `/api/news` 接口获取资讯列表数据。

    ```dart
    // lib/pages/home/info/index.dart
    // ...
    class _InfoState extends State<Info> {
      List<InfoItem> _infoList = [];

      @override
      void initState() {
        super.initState();
        _fetchNewsData(); // 调用方法获取资讯数据
      }

      Future<void> _fetchNewsData() async {
        try {
          final res = await DioHttp.of(context).get('/api/news'); // 发送 API 请求
          if (res.data != null && res.data is List) {
            List<InfoItem> newsItems = (res.data as List)
                .map((item) => InfoItem( // 将 API 返回的数据映射为 InfoItem 对象
                      item['title'],
                      item['imageUrl'],
                      item['source'],
                      item['time'],
                      item['navigateUrl'],
                    ))
                .toList();
            setState(() {
              _infoList = newsItems; // 更新状态，触发 UI 刷新
            });
          }
        } catch (e) {
          print('Error fetching news data: $e');
          // 错误处理
        }
      }
      // ...
    }
    // ...
    ```

2.  **展示资讯列表**: 在 `build` 方法中，使用 `Column` 和 `map` 方法遍历 `_infoList`，为每个资讯项创建一个 `InfoItemWidget` 组件进行展示。

    ```dart
    // lib/pages/home/info/index.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Column(
        children: [
          Column(
            children: [
              if (widget.showTitle)
                // ... (标题部分)
              Column(
                children: _infoList.map((item) => InfoItemWidget(data: item)).toList(), // 遍历资讯列表，创建 InfoItemWidget
              )
            ],
          )
        ],
      );
    }
    // ...
    ```

---

### 5.3.1 资讯详情实现

资讯详情页面 [`lib/pages/home/info/news_detail_page.dart`](lib/pages/home/info/news_detail_page.dart) 负责展示单条资讯的详细内容。它接收一个 `InfoItem` 对象作为数据源，并在 UI 上布局显示资讯的标题、来源、时间、图片和内容。

核心代码片段（[`lib/pages/home/info/news_detail_page.dart`](lib/pages/home/info/news_detail_page.dart)）：

1.  **接收资讯数据**: `NewsDetailPage` 是一个 `StatelessWidget`，通过构造函数接收一个 `InfoItem` 类型的 `data` 参数。

    ```dart
    // lib/pages/home/info/news_detail_page.dart
    // ...
    class NewsDetailPage extends StatelessWidget {
      final InfoItem data; // 接收资讯数据

      const NewsDetailPage({Key? key, required this.data}) : super(key: key);
      // ...
    }
    // ...
    ```

2.  **布局展示资讯内容**: 在 `build` 方法中，使用 `Scaffold` 构建页面结构，并在 `body` 中使用 `SingleChildScrollView` 和 `Column` 来布局展示资讯的各个部分，包括标题、来源、时间、图片和内容。

    ```dart
    // lib/pages/home/info/news_detail_page.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('资讯详情'),
        ),
        body: SingleChildScrollView( // 允许内容滚动
          child: Column(
            crossAxisAlignment: CrossAxisAlignment.start,
            children: [
              // 标题
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Text(
                  data.title, // 显示资讯标题
                  style: const TextStyle(
                    fontSize: 20,
                    fontWeight: FontWeight.bold,
                  ),
                ),
              ),
              // 作者和时间
              Padding(
                padding: const EdgeInsets.symmetric(horizontal: 16.0),
                child: Row(
                  children: [
                    Text(
                      data.source, // 显示资讯来源
                      style: const TextStyle(color: Colors.grey),
                    ),
                    const SizedBox(width: 20),
                    Text(
                      data.time, // 显示资讯时间
                      style: const TextStyle(color: Colors.grey),
                    ),
                  ],
                ),
              ),
              // 图片
              if (data.imageUrl.isNotEmpty) // 如果有图片 URL 则显示图片
                Padding(
                  padding: const EdgeInsets.all(16.0),
                  child: Center(
                    child: Image.network( // 加载网络图片
                      data.imageUrl,
                      fit: BoxFit.cover,
                    ),
                  ),
                ),
              // 内容 (目前仅展示标题作为示例内容)
              Padding(
                padding: const EdgeInsets.all(16.0),
                child: Text(
                  data.title, // 显示资讯内容 (待完善为实际内容)
                  style: const TextStyle(
                    fontSize: 16,
                    height: 1.5,
                  ),
                ),
              ),
            ],
          ),
        ),
      );
    }
    // ...
    ```

请注意，当前代码中资讯详情的内容部分 (`data.title`) 只是一个占位符，实际应用中需要从后端获取完整的资讯内容并在此处展示。

---

### 5.4.1 用户登录注册功能实现 - 登录

用户登录功能主要在 [`lib/pages/login.dart`](lib/pages/login.dart) 文件中实现。它包括用户界面的构建、用户输入的处理以及与后端登录接口的交互。

核心代码片段（[`lib/pages/login.dart`](lib/pages/login.dart)）：

1.  **用户界面**: 使用 `Scaffold` 构建页面结构，包含 AppBar 和一个包含用户名和密码输入框以及登录按钮的 `ListView`。

    ```dart
    // lib/pages/login.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(title: const Text('登录')),
        body: SafeArea(
          minimum: const EdgeInsets.all(30),
          child: ListView(children: [
            TextField( // 用户名输入框
              controller: usernameController,
              decoration:
                  const InputDecoration(labelText: '用户名', hintText: '请输入用户名'),
            ),
            const Padding(padding: EdgeInsets.all(10)),
            TextField( // 密码输入框
              controller: passwordController,
              obscureText: !_showPassword, // 控制密码是否可见
              decoration: InputDecoration(
                  labelText: '密码',
                  hintText: '请输入密码',
                  suffixIcon: IconButton( // 密码可见性切换按钮
                      onPressed: () {
                        setState(() {
                          _showPassword = !_showPassword;
                        });
                      },
                      icon: Icon(_showPassword
                          ? Icons.visibility_off
                          : Icons.visibility))),
            ),
            const Padding(padding: EdgeInsets.all(20)),
            ElevatedButton( // 登录按钮
                onPressed: () {
                  _loginHandle(); // 点击按钮触发登录处理函数
                },
                child: const Text('登录')),
            // ... (去注册按钮)
          ]),
        ),
      ),
    );
    // ...
    ```

2.  **登录处理函数**: `_loginHandle` 方法负责处理登录逻辑。它获取用户输入的用户名和密码，进行简单的非空校验，然后使用 `DioHttp` 发送 POST 请求到后端登录接口 `/api/auth/login`。

    ```dart
    // lib/pages/login.dart
    // ...
    _loginHandle() async {
      var username = usernameController.text;
      var password = passwordController.text;
      if (username.isEmpty || password.isEmpty) {
        CommonToast.showToast("用户名或密码不能为空！");
        return;
      }
      const url = '/api/auth/login'; // 后端登录接口地址
      var params = { // 请求参数
        "username": username,
        "password": password,
      };

      try {
        var response = await DioHttp.of(context).post(url, data: params); // 发送 POST 请求

        if (response.data != null && response.data is Map<String, dynamic>) {
          Map<String, dynamic> resMap = response.data as Map<String, dynamic>;

          if (response.statusCode == 200 && resMap.containsKey('token')) {
            String token = resMap['token'];
            String message = resMap['message'] ?? '登录成功';
            CommonToast.showToast(message);

            Store store = await Store.getInstance();
            await store.setString(StoreKeys.token, token); // 保存 token 到本地存储

            ScopedModelHelper.getModel<AuthModel>(context).login(token, context); // 更新 AuthModel 中的登录状态

            // 导航到主页并移除之前路由
            Timer(const Duration(seconds: 1), () {
              if (mounted) { // 检查widget是否还在树中
                Navigator.of(context).pushNamedAndRemoveUntil('/', (route) => false);
              }
            });
          } else {
            // 处理登录失败的情况，例如密码错误
            String errorMessage = resMap['message'] ?? '登录失败，请检查用户名和密码';
            CommonToast.showToast(errorMessage); // 显示登录失败信息
          }
        } else {
          CommonToast.showToast('登录失败：响应格式不正确');
        }
      } catch (e) {
        // 处理DioException或其他网络错误
        CommonToast.showToast('登录请求失败，请稍后再试'); // 处理网络请求错误
        print('Login Error: $e');
        // 可以在这里添加更详细的错误处理，例如根据 DioException 的类型
      }
    }
    // ...
    ```

3.  **状态管理**: 使用 `ScopedModel` 的 `AuthModel` 来管理用户的登录状态。登录成功后，将获取到的 token 更新到 `AuthModel` 中。

    ```dart
    // lib/pages/login.dart
    // ...
    import '../scoped_model/auth.dart'; // 导入 AuthModel
    import 'utils/scoped_model_helper.dart'; // 导入 ScopedModelHelper
    // ...
    ScopedModelHelper.getModel<AuthModel>(context).login(token, context); // 更新 AuthModel
    // ...
    ```

---

### 5.4.1 用户登录注册功能实现 - 注册

用户注册功能主要在 [`lib/pages/register.dart`](lib/pages/register.dart) 文件中实现。它负责构建注册界面，处理用户输入的用户名、密码和确认密码，并与后端注册接口进行交互。

核心代码片段（[`lib/pages/register.dart`](lib/pages/register.dart)）：

1.  **用户界面**: 使用 `Scaffold` 构建页面结构，包含 AppBar 和一个包含用户名、密码和确认密码输入框以及注册按钮的 `ListView`。

    ```dart
    // lib/pages/register.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(title: const Text('注册')),
        body: SafeArea(
          minimum: const EdgeInsets.all(30),
          child: ListView(children: [
            TextField( // 用户名输入框
              controller: usernameController,
              decoration: InputDecoration(labelText: '用户名', hintText: '请输入用户名'),
            ),
            const Padding(padding: EdgeInsets.all(10)),
            TextField( // 密码输入框
              controller: passwordController,
              decoration: const InputDecoration(
                labelText: '密码',
                hintText: '请输入密码',
              ),
            ),
            const Padding(padding: EdgeInsets.all(10)),
            TextField( // 确认密码输入框
              controller: repeatPasswordController,
              decoration: const InputDecoration(
                labelText: '确认密码',
                hintText: '请输入密码',
              ),
            ),
            const Padding(padding: EdgeInsets.all(20)),
            ElevatedButton( // 注册按钮
                onPressed: () {
                  _registerHandler(); // 点击按钮触发注册处理函数
                },
                child: const Text('注册')),
            // ... (去登录按钮)
          ]),
        ),
      );
    }
    // ...
    ```

2.  **注册处理函数**: `_registerHandler` 方法负责处理注册逻辑。它获取用户输入的用户名、密码和确认密码，进行非空和密码一致性校验，然后使用 `DioHttp` 发送 POST 请求到后端注册接口 `/api/auth/register`。

    ```dart
    // lib/pages/register.dart
    // ...
    _registerHandler() async {
      var username = usernameController.text;
      var password = passwordController.text;
      var repeatPassword = repeatPasswordController.text;

      if (username.isEmpty) {
        _showToast('用户名不能为空');
        return;
      }
      if (password.isEmpty) {
        _showToast('密码不能为空');
        return;
      }
      if (password.length < 6) {
        _showToast('密码长度不能小于6位');
        return;
      }
      if (repeatPassword.isEmpty) {
        _showToast('请确认密码');
        return;
      }
      if (password != repeatPassword) {
        _showToast('两次输入的密码不一致');
        return;
      }

      String path = '/api/auth/register'; // 后端注册接口地址
      var params = { // 请求参数
        'username': username,
        'password': password,
      };
      try {
        var response =
            await DioHttp.of(context).post(path, data: params); // 发送 POST 请求

        Map<String, dynamic>? resData = response.data is Map<String, dynamic> ? response.data as Map<String, dynamic> : null;

        if (resData != null) {
          if (response.statusCode == 200 || response.statusCode == 201) {
            _showToast(resData['message'] ?? '注册成功'); // 显示注册成功信息
            Navigator.of(context).pushReplacementNamed('login'); // 注册成功后跳转到登录页
          } else {
            String errorMessage = resData['message'] ?? resData['error'] ?? '注册失败，请稍后再试';
            _showToast(errorMessage); // 显示注册失败信息
          }
        } else {
           _showToast('注册失败：响应格式不正确');
        }
      } catch (e) {
        print('Registration Error Details: $e');
        if (e is DioException) {
          print('DioException Response: ${e.response}');
          print('DioException Type: ${e.type}');
          print('DioException Message: ${e.message}');
          print('DioException Underlying Error: ${e.error}');
        }
        _showToast('注册请求失败，详情请查看控制台'); // 处理网络请求错误
      }
    }
    // ...
    ```

---

### 5.4.2 个人资料编辑实现

个人资料编辑功能主要在 [`lib/pages/profile_edit.dart`](lib/pages/profile_edit.dart) 文件中实现。它提供一个表单，允许用户修改用户名和密码，并将修改后的信息提交到后端。

核心代码片段（[`lib/pages/profile_edit.dart`](lib/pages/profile_edit.dart)）：

1.  **用户界面**: 使用 `Scaffold` 构建页面结构，包含 AppBar 和一个包含用户名、当前密码、新密码和确认新密码输入框以及保存按钮的 `Form`。

    ```dart
    // lib/pages/profile_edit.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('编辑个人资料'),
        ),
        body: Padding(
          padding: const EdgeInsets.all(16.0),
          child: Form( // 表单
            key: _formKey,
            child: ListView( // 表单项列表
              children: <Widget>[
                TextFormField( // 用户名输入框
                  controller: _usernameController,
                  decoration: const InputDecoration(labelText: '用户名'),
                  validator: (value) {
                    if (value == null || value.isEmpty) {
                      return '请输入用户名';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                TextFormField( // 当前密码输入框
                  controller: _currentPasswordController,
                  decoration: const InputDecoration(labelText: '当前密码 (修改密码时必填)'),
                  obscureText: true,
                  validator: (value) {
                    // Only validate if new password is also entered
                    if (_passwordController.text.isNotEmpty && (value == null || value.isEmpty)) {
                      return '请输入当前密码以修改新密码';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 20),
                TextFormField( // 新密码输入框
                  controller: _passwordController,
                  decoration: const InputDecoration(labelText: '新密码 (留空则不修改)'),
                  obscureText: true,
                ),
                const SizedBox(height: 20),
                TextFormField( // 确认新密码输入框
                  controller: _confirmPasswordController,
                  decoration: const InputDecoration(labelText: '确认新密码'),
                  obscureText: true,
                  validator: (value) {
                    if (_passwordController.text.isNotEmpty && value != _passwordController.text) {
                      return '两次输入的密码不一致';
                    }
                    return null;
                  },
                ),
                const SizedBox(height: 30),
                ElevatedButton( // 保存按钮
                  onPressed: _submitForm, // 点击按钮触发提交表单函数
                  child: const Text('保存'),
                ),
              ],
            ),
          ),
        ),
      );
    }
    // ...
    ```

2.  **加载用户信息**: 在 `initState` 中调用 `_loadUserInfo` 方法，从 `AuthModel` 中获取当前用户的个人信息，并填充到用户名输入框中。

    ```dart
    // lib/pages/profile_edit.dart
    // ...
    @override
    void initState() {
      super.initState();
      _loadUserInfo(); // 加载用户信息
    }
    Future<void> _loadUserInfo() async {
      var userInfo = ScopedModelHelper.getModel<AuthModel>(context).userInfo;
      setState(() {
        _userInfo = userInfo;
        if (_userInfo != null) {
          _usernameController.text = _userInfo!.nickname ?? ''; // 填充用户名
        }
      });
    }
    // ...
    ```

3.  **提交表单**: `_submitForm` 方法负责处理表单提交逻辑。它验证表单，构建更新数据，并使用 `DioHttp` 发送 PUT 请求到后端接口 `/api/auth/me` 更新用户信息。

    ```dart
    // lib/pages/profile_edit.dart
    // ...
    Future<void> _submitForm() async {
      if (_formKey.currentState!.validate()) { // 验证表单
        String newUsername = _usernameController.text;
        String currentPassword = _currentPasswordController.text;
        String newPassword = _passwordController.text;

        var auth = ScopedModelHelper.getModel<AuthModel>(context);
        Map<String, dynamic> updateData = { // 构建更新数据
          'username': newUsername,
          'nickname': newUsername,
        };

        if (newPassword.isNotEmpty) { // 如果输入了新密码，则添加密码相关字段
          if (currentPassword.isEmpty) {
            CommonToast.showToast('请输入当前密码以设置新密码');
            return;
          }
          updateData['password'] = newPassword;
          updateData['currentPassword'] = currentPassword;
        }

        try {
          print('[ProfileEdit] Sending update request: $updateData');
          var response = await DioHttp.of(context).put( // 发送 PUT 请求
            '/api/auth/me',
            data: updateData,
            token: auth.token, // 携带 token 进行认证
          );

          print('[ProfileEdit] Server response: ${response.data}');

          if (response.statusCode == 200 && response.data != null) {
            Map<String, dynamic> resData = response.data;
            if (resData.containsKey('user') || resData.containsKey('message')) {
              CommonToast.showToast(resData['message'] ?? '个人资料更新成功'); // 显示成功信息
              await auth.refreshUserInfo(context); // 刷新 AuthModel 中的用户信息
              if (mounted) {
                Navigator.pop(context); // 返回上一页
              }
            } else {
              String message = resData['message'] ?? '个人资料更新失败';
              CommonToast.showToast(message); // 显示失败信息
            }
          } else {
            CommonToast.showToast('个人资料更新失败: 服务器响应异常');
          }
        } catch (e) {
          print('[ProfileEdit] Error updating profile: $e');
          CommonToast.showToast('个人资料更新失败，请稍后重试'); // 处理网络请求错误
        }
      }
    }
    // ...
    ```

4.  **状态管理**: 使用 `ScopedModel` 的 `AuthModel` 来获取当前用户信息和在更新成功后刷新用户信息。

    ```dart
    // lib/pages/profile_edit.dart
    // ...
    import 'package:rent_share/scoped_model/auth.dart'; // 导入 AuthModel
    import 'package:rent_share/pages/utils/scoped_model_helper.dart'; // 导入 ScopedModelHelper
    // ...
    var userInfo = ScopedModelHelper.getModel<AuthModel>(context).userInfo; // 获取用户信息
    // ...
    await auth.refreshUserInfo(context); // 刷新用户信息
    // ...
    ```

---

### 5.4.3 我的收藏和我的预约功能实现 - 我的收藏

我的收藏功能主要在 [`lib/pages/room_favorite/index.dart`](lib/pages/room_favorite/index.dart) 文件中实现。它负责从后端获取当前用户收藏的房源列表，并在 UI 上进行展示。

核心代码片段（[`lib/pages/room_favorite/index.dart`](lib/pages/room_favorite/index.dart)）：

1.  **获取收藏列表**: 在 `initState` 中调用 `_fetchFavorites` 方法，该方法会检查用户是否登录，如果已登录，则调用 `_getFavorites` 方法通过 `DioHttp` 发送 GET 请求到后端接口 `/api/me/favorites` 获取收藏列表数据，并携带用户的 token 进行认证。

    ```dart
    // lib/pages/room_favorite/index.dart
    // ...
    class _RoomFavoritePageState extends State<RoomFavoritePage> {
      Future<List<RoomListItemData>>? _favoriteFuture;

      @override
      void initState() {
        super.initState();
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) { // Check if the widget is still in the tree
            _fetchFavorites(); // 调用方法获取收藏列表
          }
        });
      }

      Future<void> _fetchFavorites() async {
        if (!mounted) return;
        // Get AuthModel here as context should be ready
        final auth = ScopedModelHelper.getModel<AuthModel>(context);
        print('[RoomFavoritePage] Fetching favorites. IsLogin: ${auth.isLogin}, Token: ${auth.token}');

        if (!auth.isLogin) {
           setState(() {
            _favoriteFuture = Future.value([]); // 未登录则返回空列表
          });
          print('[RoomFavoritePage] User not logged in. Not fetching favorites.');
          return;
        }

        setState(() {
          _favoriteFuture = _getFavorites(auth.token); // 调用 _getFavorites 获取数据
        });
      }

      Future<List<RoomListItemData>> _getFavorites(String? token) async { // Accept token as parameter
        if (!mounted) return [];

        // Log the token being used for the API call
        print('[RoomFavoritePage] _getFavorites called with token: $token');

        if (token == null || token.isEmpty) {
          print('[RoomFavoritePage] Token is null or empty. Cannot fetch favorites.');
          // Optionally throw an exception to be caught by FutureBuilder
          // throw Exception('User not authenticated.');
          return []; // Return empty list if no token
        }

        try {
          final response = await DioHttp.of(context).get( // 发送 GET 请求
            '${Config.BaseUrl}api/me/favorites',
            null,
            token, // 携带 token
          );
          if (response.statusCode == 200 && response.data != null) {
            List<dynamic> favoriteEntries = response.data as List<dynamic>;

            List<RoomListItemData> mappedFavorites = favoriteEntries.map<RoomListItemData>((entry) {
              var roomData = entry['room'];
              if (roomData == null) {
                // 处理无效的收藏项
                return RoomListItemData(
                  id: entry['_id']?.toString() ?? 'unknown_fav_id_${DateTime.now().millisecondsSinceEpoch}',
                  title: '无效的收藏房源',
                  subTitle: '该房源信息已失效',
                  imageUrl: 'static/images/loading.jpg',
                  price: 0,
                  tags: [],
                );
              }
              // 将后端返回的房源数据映射为 RoomListItemData 对象
              String imageUrl = 'static/images/loading.jpg'; // Default image
              if (roomData['images'] != null && (roomData['images'] as List).isNotEmpty) {
                String rawImageUrl = (roomData['images'] as List)[0] as String;
                if (rawImageUrl.startsWith('http')) {
                  imageUrl = rawImageUrl;
                } else {
                  // Ensure Config.BaseUrl ends with a slash if rawImageUrl doesn't start with one
                  String baseUrl = Config.BaseUrl.endsWith('/') ? Config.BaseUrl : '${Config.BaseUrl}/';
                  String imagePath = rawImageUrl.startsWith('/') ? rawImageUrl.substring(1) : rawImageUrl;
                  imageUrl = baseUrl + imagePath;
                }
              }

              return RoomListItemData(
                id: roomData['_id']?.toString() ?? entry['_id']?.toString() ?? 'unknown_room_id_${DateTime.now().millisecondsSinceEpoch}',
                title: roomData['title'] ?? '未知标题',
                subTitle: '${roomData['district'] ?? '未知区域'} - ${roomData['roomType'] ?? '未知户型'} ${roomData['city'] != null ? '('+roomData['city']+')' : ''}', // City info can be part of subtitle
                imageUrl: imageUrl,
                price: (roomData['price'] as num?)?.toInt() ?? 0, // Ensure price is int
                tags: roomData['rentType'] != null ? [roomData['rentType'] as String] : [],
              );
            }).toList();
            return mappedFavorites; // 返回映射后的列表
          } else {
            throw Exception('Failed to load favorites: ${response.statusCode}');
          }
        } catch (e) {
          print('Error fetching favorites: $e');
          // It's better to let FutureBuilder handle the error state
          // by rethrowing or returning a future that completes with an error.
          rethrow; // Rethrow the exception to be caught by FutureBuilder
        }
      }
      // ...
    }
    // ...
    ```

2.  **展示收藏列表**: 在 `build` 方法中，使用 `FutureBuilder` 来处理异步获取的收藏列表数据。根据 `Future` 的状态（等待中、出错、有数据、无数据），显示不同的 UI（加载指示器、错误信息、房源列表、空状态提示）。当有数据时，使用 `ListView.builder` 遍历收藏列表，为每个收藏的房源创建一个 `RoomListItemWidget` 组件进行展示。

    ```dart
    // lib/pages/room_favorite/index.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('我的收藏'),
          centerTitle: true,
        ),
        body: FutureBuilder<List<RoomListItemData>>( // 使用 FutureBuilder 处理异步数据
          future: _favoriteFuture,
          builder: (context, snapshot) {
            if (snapshot.connectionState == ConnectionState.waiting) {
              return const Center(child: CircularProgressIndicator()); // 加载中
            } else if (snapshot.hasError) {
              return Center( // 加载失败
                child: Column(
                  mainAxisAlignment: MainAxisAlignment.center,
                  children: [
                    Text('加载失败: ${snapshot.error}'),
                    const SizedBox(height: 10),
                    ElevatedButton(
                      onPressed: _fetchFavorites, // 重试按钮
                      child: const Text('重试'),
                    ),
                  ],
                ),
              );
            } else if (snapshot.hasData && snapshot.data!.isNotEmpty) {
              final favorites = snapshot.data!;
              return ListView.builder( // 展示房源列表
                itemCount: favorites.length,
                itemBuilder: (context, index) {
                  final favoriteRoom = favorites[index];
                  return RoomListItemWidget(data: favoriteRoom); // 使用 RoomListItemWidget 展示房源项
                },
              );
            } else {
              return const Center( // 列表为空
                child: Text('您还没有收藏任何房源'),
              );
            }
          },
        ),
      );
    }
    // ...
    ```

---

### 5.4.3 我的收藏和我的预约功能实现 - 我的预约

我的预约功能主要在 [`lib/pages/my_orders/index.dart`](lib/pages/my_orders/index.dart) 文件中实现。它负责从后端获取当前用户的预约列表，并在 UI 上进行展示。

核心代码片段（[`lib/pages/my_orders/index.dart`](lib/pages/my_orders/index.dart)）：

1.  **预约数据模型**: 定义 `OrderItemData` 类用于表示单条预约的数据结构，其中包含了房源信息 (`RoomListItemData`)、预约状态、预约时间等。

    ```dart
    // lib/pages/my_orders/index.dart
    // ...
    class OrderItemData {
      final String id;
      final RoomListItemData room; // 复用房源列表项数据模型
      final String status;
      final DateTime? appointmentTime;
      final String publisherUsername;
      final DateTime createdAt;

      OrderItemData({
        required this.id,
        required this.room,
        required this.status,
        this.appointmentTime,
        required this.publisherUsername,
        required this.createdAt,
      });

      factory OrderItemData.fromJson(Map<String, dynamic> json) {
        // ... (从 JSON 解析数据，包括房源信息)
        if (json['room'] == null) {
          // 处理房源信息缺失的情况
          // ...
        }
        var roomDataJson = json['room'] as Map<String, dynamic>;
        // ... (解析房源图片、标签等)

        return OrderItemData(
          id: json['_id'] ?? '',
          room: RoomListItemData( // 创建 RoomListItemData 对象
            id: roomDataJson['_id'] ?? '',
            title: roomDataJson['title'] ?? '未知标题',
            subTitle: roomDataJson['address'] ?? roomDataJson['district'] ?? '未知位置',
            imageUrl: images.isNotEmpty ? images[0] : Config.DefaultImage,
            price: roomDataJson['price'] ?? 0,
            tags: tags,
          ),
          status: json['status'] ?? 'unknown',
          appointmentTime: json['appointmentTime'] != null ? DateTime.parse(json['appointmentTime']) : null,
          publisherUsername: json['publisher'] != null ? (json['publisher']['username'] ?? '未知房东') : '未知房东',
          createdAt: DateTime.parse(json['createdAt'] ?? DateTime.now().toIso8601String()),
        );
      }
    }
    // ...
    ```

2.  **获取预约列表**: 在 `initState` 中调用 `_fetchOrders` 方法。该方法检查用户是否登录，如果已登录且 token 存在，则通过 `DioHttp` 发送 GET 请求到后端接口 `/api/me/orders` 获取预约列表数据，并携带用户的 token 进行认证。

    ```dart
    // lib/pages/my_orders/index.dart
    // ...
    class _MyOrdersPageState extends State<MyOrdersPage> {
      List<OrderItemData> _orders = [];
      bool _isLoading = true;

      @override
      void initState() {
        super.initState();
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (mounted) { // Ensure the state is still mounted
            _fetchOrders(); // 调用方法获取预约列表
          }
        });
      }

      Future<void> _fetchOrders() async {
        print('[MyOrdersPage] _fetchOrders called');
        var auth = ScopedModel.of<AuthModel>(context, rebuildOnChange: false);

        print('[MyOrdersPage] AuthModel: isLogin=${auth.isLogin}, token=${auth.token != null ? " vorhanden" : "nicht vorhanden"}');

        if (auth.isLogin && auth.token != null) {
          setState(() {
            _isLoading = true; // 显示加载指示器
          });
          try {
            print('[MyOrdersPage] Attempting to fetch orders from /me/orders');
            // Use DioHttp.of(context) instead of DioHttp.instance
            final response = await DioHttp.of(context).get( // 发送 GET 请求
              '/api/me/orders',
              null,
              auth.token, // 携带 token
            );
            print('[MyOrdersPage] Orders API response status: ${response.statusCode}');
            // Note: The original getRequest in my_orders was trying to use 'options' directly,
            // but the DioHttp.get method takes params and token separately.
            // If specific options (like headers) are needed beyond what DioHttp.get provides by default for token,
            // DioHttp class might need adjustment or use the post method if more complex options are a must.
            // For now, assuming the token is the main header to be set, which DioHttp.get handles.

            if (response.data != null && response.data is List) { // Removed null check for response itself as Dio throws on error
              List<dynamic> dataList = response.data;
              print('[MyOrdersPage] Orders data received: ${dataList.length} items');
              if (dataList.isEmpty) {
                print('[MyOrdersPage] Orders data is empty list.');
              }
              setState(() {
                _orders = dataList
                    .where((item) => item != null) // Filter out null items
                    .map((item) => OrderItemData.fromJson(item as Map<String, dynamic>)) // 将数据映射为 OrderItemData 对象
                    .toList();
                _isLoading = false; // 隐藏加载指示器
                print('[MyOrdersPage] Orders loaded and UI updated. isLoading: $_isLoading');
              });
            } else {
              print('[MyOrdersPage] Failed to get orders or data format is incorrect. Response data: ${response.data}');
              CommonToast.showToast('获取预约失败或数据格式不正确');
              setState(() {
                _isLoading = false;
                print('[MyOrdersPage] isLoading set to false due to incorrect data format.');
              });
            }
          } catch (e) {
            print('[MyOrdersPage] Error fetching orders: $e');
            CommonToast.showToast('获取预约列表失败: $e');
            setState(() {
              _isLoading = false;
              print('[MyOrdersPage] isLoading set to false due to an error.');
            });
          }
        } else {
          print('[MyOrdersPage] User not logged in or token is null.');
          CommonToast.showToast('请先登录'); // 未登录提示
          setState(() {
            _isLoading = false;
            print('[MyOrdersPage] isLoading set to false because user is not logged in.');
          });
          // 可以考虑跳转到登录页
          // Navigator.of(context).pushNamed('login');
        }
      }
      // ...
    }
    // ...
    ```

3.  **展示预约列表**: 在 `build` 方法中，根据加载状态和预约列表是否为空，显示不同的 UI。当加载完成且预约列表不为空时，使用 `ListView.builder` 遍历预约列表，为每个预约项创建一个 `Card`，并在其中复用 `RoomListItemWidget` 展示房源信息，同时添加预约特定的信息（如房东、预约时间、状态等）。

    ```dart
    // lib/pages/my_orders/index.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(
          title: const Text('我的预约'),
          elevation: 0,
        ),
        body: _isLoading // 根据加载状态显示不同 UI
            ? const Center(child: CircularProgressIndicator())
            : _orders.isEmpty // 根据列表是否为空显示不同 UI
                ? const Center(child: Text('您还没有预约'))
                : ListView.builder( // 展示预约列表
                    itemCount: _orders.length,
                    itemBuilder: (context, index) {
                      final order = _orders[index];
                      return Card( // 每个预约项使用 Card 包裹
                        margin: const EdgeInsets.symmetric(horizontal: 8.0, vertical: 4.0),
                        child: Padding(
                          padding: const EdgeInsets.all(8.0),
                          child: Column(
                            crossAxisAlignment: CrossAxisAlignment.start,
                            children: [
                              RoomListItemWidget(data: order.room), // 复用房源列表项组件展示房源信息
                              const SizedBox(height: 8.0),
                              Row( // 展示房东和预约状态
                                mainAxisAlignment: MainAxisAlignment.spaceBetween,
                                children: [
                                  Text('房东: ${order.publisherUsername}'),
                                  _buildOrderStatus(order.status), // 显示预约状态
                                ],
                              ),
                            ),
                            const SizedBox(height: 4.0),
                            if (order.appointmentTime != null) // 如果有预约时间则显示
                              Text('预约时间: ${order.appointmentTime!.toLocal().toString().substring(0, 16)}'),
                            Text('下单时间: ${order.createdAt.toLocal().toString().substring(0, 16)}'), // 显示下单时间
                            // TODO: 可以添加取消预约等操作按钮
                          ],
                        ),
                      ),
                    );
                  },
                ),
      );
    }
    // ...
    ```

4.  **预约状态展示**: `_buildOrderStatus` 方法根据预约状态字符串返回对应的文本和颜色，用于在 UI 上直观展示预约状态。

    ```dart
    // lib/pages/my_orders/index.dart
    // ...
    Widget _buildOrderStatus(String status) {
      Color statusColor;
      String statusText;
      switch (status) {
        case 'pending':
          statusText = '待确认';
          statusColor = Colors.orange;
          break;
        case 'confirmed':
          statusText = '已确认';
          statusColor = Colors.green;
          break;
        case 'cancelled_by_user':
          statusText = '已取消(用户)';
          statusColor = Colors.grey;
          break;
        case 'cancelled_by_publisher':
          statusText = '已取消(房东)';
          statusColor = Colors.redAccent;
          break;
        case 'completed':
          statusText = '已完成';
          statusColor = Colors.blue;
          break;
        case 'expired':
          statusText = '已过期';
          statusColor = Colors.purple;
          break;
        default:
          statusText = '未知状态';
          statusColor = Colors.black54;
      }
      return Text(statusText, style: TextStyle(color: statusColor, fontWeight: FontWeight.bold));
    }
    // ...
    ```

---

### 5.4.4 发布房源功能实现

发布房源功能主要在 [`lib/pages/room_add/index.dart`](lib/pages/room_add/index.dart) 文件中实现。它提供一个表单页面，用户可以在其中填写房源的详细信息，包括城市、行政区、小区/地址、租金、大小、租赁方式、户型、楼层、朝向、装修、房屋图像、房屋标题、房屋配置和房屋描述，并将这些信息提交到后端。该页面也支持编辑现有房源。

核心代码片段（[`lib/pages/room_add/index.dart`](lib/pages/room_add/index.dart)）：

1.  **用户界面**: 使用 `Scaffold` 构建页面结构，包含 AppBar、一个用于提交的浮动按钮以及一个包含各种表单项的 `ListView`。

    ```dart
    // lib/pages/room_add/index.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        appBar: AppBar(title: Text(widget.isEdit ? '编辑房源' : '发布房源')), // 根据是否编辑模式显示不同标题
        floatingActionButtonLocation: FloatingActionButtonLocation.centerFloat,
        floatingActionButton: CommonFloatingActionButton('提交', _submit), // 提交按钮
        body: ListView( // 表单项列表
          padding: const EdgeInsets.only(bottom: 80),
          children: [
            const CommonTitle('房源信息'),
            // 城市选择
            CommonSelectFormItem(
              label: '城市',
              value: _cities.indexWhere((item) => item.name == _selectedCityName),
              onChange: (val) {
                // ... (城市选择逻辑)
              },
              options: _cities.map((item) => item.name).toList(),
            ),
            // 区域选择
            if (_districts.isNotEmpty)
              CommonSelectFormItem(
                label: '行政区',
                value: _districts.indexWhere((item) => item.name == _selectedDistrict),
                onChange: (val) {
                  // ... (区域选择逻辑)
                },
                options: _districts.map((item) => item.name).toList(),
              ),
             CommonFormItem( // 小区/地址输入框
              label: '小区/地址',
              hintText: '请输入小区名称或详细地址',
              controller: communityController,
            ),
            CommonFormItem( // 租金输入框
              label: '租金',
              suffixText: '元/月',
              hintText: '请输入租金',
              controller: priceController,
              keyboardType: TextInputType.number,
            ),
            CommonFormItem( // 大小输入框
              label: '大小',
              suffixText: '平方米',
              hintText: '请输入房屋大小 (将作为标签)',
              controller: sizeController,
              keyboardType: TextInputType.number,
            ),
            CommonRadioFormItem( // 租赁方式选择
              label: '租赁方式',
              options: const ['合租', '整租'],
              value: rentType,
              onChange: (index) {
                setState(() => rentType = index!);
              },
            ),
            CommonSelectFormItem( // 户型选择
              label: '户型',
              value: filter_data.roomTypeList.indexWhere((item) => item.id == selectedRoomTypeId),
              onChange: (val) {
                // ... (户型选择逻辑)
              },
              options: filter_data.roomTypeList.map((item) => item.name).toList(),
            ),
            CommonSelectFormItem( // 楼层选择
              label: '楼层',
              value: filter_data.floorList.indexWhere((item) => item.id == selectedFloorId),
              onChange: (val) {
                // ... (楼层选择逻辑)
              },
              options: filter_data.floorList.map((item) => item.name).toList(),
            ),
            CommonSelectFormItem( // 朝向选择
              label: '朝向',
              value: filter_data.orientedList.indexWhere((item) => item.id == selectedOrientedId),
              onChange: (val) {
                // ... (朝向选择逻辑)
              },
              options: filter_data.orientedList.map((item) => item.name).toList(),
            ),
            CommonRadioFormItem( // 装修选择
              label: '装修',
              options: const ['精装', '简装'],
              value: decorationType,
              onChange: (index) {
                setState(() => decorationType = index!);
              },
            ),
            const CommonTitle('房屋图像 (最多9张)'),
            CommonImagePicker( // 房屋图像选择器
              onChange: (xFiles) {
                setState(() {
                  _pickedImages = xFiles.map((xfile) => File(xfile.path)).toList();
                });
              },
            ),
            const CommonTitle('房屋标题'),
            Container( // 房屋标题输入框
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: TextField(
                controller: titleController,
                decoration: const InputDecoration(
                  hintText: '请输入标题（例如：整租 小区名 二室 2000元）',
                  border: InputBorder.none,
                ),
              ),
            ),
            const CommonTitle('房屋配置'),
            RoomAppliance( // 房屋配置选择器
              (selectedItems) {
                setState(() {
                  _selectedAppliances = selectedItems
                      .where((item) => item.isChecked)
                      .map((item) => item.title)
                      .toList();
                });
              },
            ),
            const CommonTitle('房屋描述'),
            Container( // 房屋描述输入框
              margin: const EdgeInsets.only(bottom: 100),
              padding: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
              child: TextField(
                controller: descController,
                maxLines: 5,
                decoration: const InputDecoration(
                  hintText: '请输入房屋描述信息',
                  border: InputBorder.none,
                ),
              ),
            ),
          ],
        ),
      );
    }
    // ...
    ```

2.  **加载城市和行政区数据**: 在 `initState` 中调用 `_loadCityDistrictData` 方法，使用 `RegionService` 加载城市和行政区数据，用于城市和行政区选择器。

    ```dart
    // lib/pages/room_add/index.dart
    // ...
    @override
    void initState() {
      super.initState();
      _loadCityDistrictData(); // 加载城市和行政区数据
      // ... (编辑模式加载房源数据)
    }

    Future<void> _loadCityDistrictData() async {
      try {
        // 确保 RegionService 已加载数据
        await RegionService.loadRegionData();

        setState(() {
          _cities = RegionService.getCityList(); // 获取城市列表

          // 预选第一个城市
          if (_cities.isNotEmpty) {
            _selectedCityName = _cities.first.name; // 预选第一个城市
            _districts = RegionService.getDistrictsByCityName(_selectedCityName!); // 获取对应行政区列表

            // 预选第一个区域
            if (_districts.isNotEmpty) {
              _selectedDistrict = _districts.isNotEmpty ? _districts.first.name : null; // 预选第一个行政区
            }
          }
        });
      } catch (e) {
        print('Error loading city and district data: $e');
        CommonToast.showToast('获取城市和行政区数据失败');
      }
    }
    // ...
    ```

3.  **加载房源数据 (编辑模式)**: 如果是编辑模式 (`widget.isEdit` 为 true 且 `widget.roomIdForEdit` 不为空)，在 `initState` 中调用 `_loadRoomData` 方法，通过后端接口获取现有房源的数据，并填充到表单中。

    ```dart
    // lib/pages/room_add/index.dart
    // ...
    // If in edit mode and roomId is provided, load room data
    if (widget.isEdit && widget.roomIdForEdit != null) {
      WidgetsBinding.instance.addPostFrameCallback((_) {
        _loadRoomData(widget.roomIdForEdit!); // 加载房源数据
      });
    }
    // ...
    Future<void> _loadRoomData(String id) async {
      try {
        final auth = ScopedModelHelper.getModel<AuthModel>(context);
        final token = auth.token;
        final DioHttp dioHttp = DioHttp.of(context);

        final response = await dioHttp.get('/api/rooms/$id', null, token); // 获取单个房源数据

        final data = response.data['data'];
        if (data != null) {
          setState(() {
            // 填充表单数据
            titleController.text = data['title'] ?? '';
            descController.text = data['description'] ?? '';
            communityController.text = data['address'] ?? '';
            priceController.text = data['price']?.toString() ?? '';
            sizeController.text = data['size']?.toString() ?? '';

            _selectedCityName = data['city'];
            _selectedDistrict = data['district'];

            rentType = data['rentType'] == '整租' ? 1 : 0;

            // 根据名称查找对应的 ID 并设置选中状态
            selectedRoomTypeId = filter_data.roomTypeList
                .firstWhere((item) => item.name == data['roomType'],
                    orElse: () => filter_data.roomTypeList.first).id;
            selectedFloorId = filter_data.floorList
                .firstWhere((item) => item.name == data['floor'],
                    orElse: () => filter_data.floorList.first).id;
            selectedOrientedId = filter_data.orientedList
                .firstWhere((item) => item.name == data['oriented'],
                    orElse: () => filter_data.orientedList.first).id;

            final tags = data['tags'] as List?;
            if (tags != null) {
              decorationType = tags.contains('精装') ? 0 : 1;
              _selectedAppliances = tags.where((tag) =>
                  !['精装', '简装'].contains(tag)).cast<String>().toList();
            }
            // ... (处理现有图片展示)
            isLoading = false;
          });
        }
      } catch (e) {
        print('Error loading room data: $e');
        CommonToast.showToast('获取房源数据失败');
        setState(() {
          isLoading = false;
        });
      }
    }
    // ...
    ```

4.  **提交房源**: `_submit` 方法负责处理房源的发布或更新。它验证表单数据，构建请求参数，包括将房屋配置和装修类型作为标签添加到 `tags` 列表中。然后，它将选中的房屋图像转换为 `FormData`，并根据是发布还是更新操作，使用 `DioHttp` 发送 POST 或 PUT 请求到后端接口 `/api/rooms` 或 `/api/rooms/:id`，并携带用户的 token 进行认证。

    ```dart
    // lib/pages/room_add/index.dart
    // ...
    Future<void> _submit() async {
      final bool isUpdate = widget.isEdit && widget.roomIdForEdit != null;
      // 1. Validate form data (省略详细校验代码)
      // ...

      // 2. Prepare data for backend
      List<String> tags = [..._selectedAppliances]; // 添加房屋配置标签
      tags.add(_getDecorationTypeString(decorationType)); // 添加装修标签
      if (size.isNotEmpty) {
        tags.add('$size平方米'); // 添加大小标签
      }

      Map<String, dynamic> params = { // 构建请求参数
        if (isUpdate) 'id': widget.roomIdForEdit,
        'title': title,
        'description': description,
        'price': parsedPrice,
        'city': city,
        'district': district,
        'address': address,
        'rentType': _getRentTypeString(rentType),
        'roomType': selectedRoomTypeId,
        'floor': selectedFloorId,
        'orientation': selectedOrientedId,
        'tags': tags,
        // 'roomImages' will be handled by FormData
      };

      // 3. Get token (省略获取 token 代码)
      // ...
      final token = auth.token;

      // 4. Prepare FormData for image uploads
      FormData formData = FormData.fromMap(params);
      if (_pickedImages.isNotEmpty) {
        for (var i = 0; i < _pickedImages.length; i++) {
          File imageFile = _pickedImages[i];
          // ... (处理图片文件并添加到 formData)
          formData.files.add(MapEntry(
            'roomImages', // 后端接收图片文件的字段名
            await MultipartFile.fromFile(
              imageFile.path,
              filename: 'room_image_$i.$extension',
              contentType: mediaType,
            ),
          ));
        }
      }

      // 5. Send request
      CommonToast.showToast('正在提交...');
      print('Attempting to submit with token: "$token"');
      try {
        var response = isUpdate // 根据是否编辑模式选择 POST 或 PUT 请求
            ? await DioHttp.of(context).put(
                '/api/rooms/${widget.roomIdForEdit}', // 更新房源接口
                data: formData,
                token: token,
              )
            : await DioHttp.of(context).post(
                '/api/rooms', // 发布房源接口
                data: formData,
                token: token,
              );

        if (response.statusCode == 201 || response.statusCode == 200) {
          CommonToast.showToast(isUpdate ? '房源更新成功！' : '房源发布成功！'); // 显示成功信息
          if (mounted) {
            Navigator.of(context).pop(true); // 返回上一页并传递成功标志
          }
        } else {
          String errorMessage = response.data?['message'] ?? (isUpdate ? '更新失败，请稍后再试' : '发布失败，请稍后再试');
          CommonToast.showToast(errorMessage); // 显示失败信息
        }
      } catch (e) {
        print('Error submitting room: $e');
        if (e is DioException && e.response?.data is Map) {
           CommonToast.showToast(e.response?.data['message'] ?? '提交失败，网络错误');
        } else {
          CommonToast.showToast('提交失败，请检查网络连接'); // 处理网络请求错误
        }
      }
    }
    // ...
    ```

---

### 5.4.5 房源管理功能实现

房源管理功能主要在 [`lib/pages/room_manage/index.dart`](lib/pages/room_manage/index.dart) 文件中实现。它负责获取当前用户发布的房源列表，并按状态（已租/空置）进行分类展示，同时提供编辑和删除房源的操作。

核心代码片段（[`lib/pages/room_manage/index.dart`](lib/pages/room_manage/index.dart)）：

1.  **获取用户房源列表**: 在 `didChangeDependencies` 中调用 `_fetchRooms` 方法，通过 `RoomService.getUserRooms` 获取当前用户发布的所有房源。

    ```dart
    // lib/pages/room_manage/index.dart
    // ...
    @override
    void didChangeDependencies() {
      super.didChangeDependencies();
      // 在 didChangeDependencies 中加载数据，这样可以安全地访问 InheritedWidget
      if (!_dataLoaded) {
        _fetchRooms(); // 调用方法获取用户房源
        _dataLoaded = true;
      }
    }

    // 获取房源数据
    Future<void> _fetchRooms() async {
      setState(() {
        _isLoading = true;
        _errorMessage = null;
      });

      try {
        // 传递 context 参数给 getUserRooms 方法
        final allRooms = await RoomService.getUserRooms(context: context); // 获取用户房源列表

        // 分类处理
        setState(() {
          _rentedRooms = allRooms.where((room) => room.status == 'rented').toList(); // 过滤出已租房源
          _availableRooms = allRooms.where((room) => room.status == 'available').toList(); // 过滤出空置房源
          _isLoading = false;
        });
      } catch (e) {
        setState(() {
          _errorMessage = '加载房源数据失败: ${e.toString()}';
          _isLoading = false;
        });
      }
    }
    // ...
    ```

2.  **TabBar 分类展示**: 使用 `TabBar` 和 `TabBarView` 将房源列表分为“已租”和“空置”两个 Tab 进行展示。

    ```dart
    // lib/pages/room_manage/index.dart
    // ...
    @override
    Widget build(BuildContext context) {
      return Scaffold(
        // ... (浮动按钮)
        appBar: AppBar(
          title: const Text('房屋管理'),
          bottom: TabBar( // TabBar 用于切换已租/空置
            controller: _tabController,
            tabs: const [
              Tab(text: '已租'),
              Tab(text: '空置'),
            ],
          ),
          // ... (刷新按钮)
        ),
        body: TabBarView( // TabBarView 展示对应列表
          controller: _tabController,
          children: [
            _buildRoomList(_rentedRooms), // 展示已租列表
            _buildRoomList(_availableRooms), // 展示空置列表
          ],
        ),
      );
    }
    // ...
    ```

3.  **构建房源列表**: `_buildRoomList` 方法根据传入的房源列表构建并返回一个 `ListView.builder`，用于展示房源列表项。它还处理加载中、加载失败和列表为空等状态的 UI 展示。

    ```dart
    // lib/pages/room_manage/index.dart
    // ...
    // 构建房源列表
    Widget _buildRoomList(List<Room> rooms) {
      if (_isLoading) {
        return const Center(child: CircularProgressIndicator()); // 加载中
      }

      if (_errorMessage != null) {
        return Center( // 加载失败
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Text(_errorMessage!, style: const TextStyle(color: Colors.red)),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: _fetchRooms,
                child: const Text('重试'),
              ),
            ],
          ),
        );
      }

      if (rooms.isEmpty) {
        return Center( // 列表为空
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              const Text('暂无房源数据'),
              const SizedBox(height: 16),
              ElevatedButton(
                onPressed: () => Navigator.pushNamed(context, '/room-add'),
                child: const Text('去发布房源'),
              ),
            ],
          ),
        );
      }

      return RefreshIndicator( // 支持下拉刷新
        onRefresh: _fetchRooms,
        child: ListView.builder( // 展示房源列表
          itemCount: rooms.length,
          itemBuilder: (context, index) {
            final room = rooms[index];
            return RoomListItemWidget( // 使用 RoomListItemWidget 展示房源项
              room: room,
              onTap: () {
                // 跳转到房源详情页
                Navigator.pushNamed(context, 'room_detail/${room.id}');
              },
              onEdit: () { // 编辑操作
                // 跳转到编辑页面
                Navigator.pushNamed(context, 'room_edit/${room.id}').then((_) {
                  _fetchRooms(); // 编辑完成后刷新数据
                });
              },
              onDelete: () => _deleteRoom(room), // 删除操作
            );
          },
        ),
      );
    }
    // ...
    ```

4.  **编辑和删除操作**: 在 `RoomListItemWidget` 的回调函数中处理编辑 (`onEdit`) 和删除 (`onDelete`) 操作。编辑操作会导航到房源发布/编辑页面，删除操作会弹出确认对话框并调用 `RoomService.deleteRoom` 删除房源。

    ```dart
    // lib/pages/room_manage/index.dart
    // ...
    // 删除房源
    Future<void> _deleteRoom(Room room) async {
      // 显示确认对话框
      final confirm = await showDialog<bool>(
        context: context,
        builder: (context) => AlertDialog(
          title: const Text('确认删除'),
          content: Text('确定要删除房源「${room.title}」吗？此操作不可恢复。'),
          actions: [
            TextButton(
              onPressed: () => Navigator.of(context).pop(false),
              child: const Text('取消'),
            ),
            TextButton(
              onPressed: () => Navigator.of(context).pop(true),
              child: const Text('删除', style: TextStyle(color: Colors.red)),
            ),
          ],
        ),
      );

      if (confirm != true) return;

      try {
        final success = await RoomService.deleteRoom(room.id, context: context); // 调用 RoomService 删除房源
        if (success) {
          ScaffoldMessenger.of(context).showSnackBar(
            const SnackBar(content: Text('房源删除成功')),
          );
          _fetchRooms(); // 重新加载数据
        }
      } catch (e) {
        ScaffoldMessenger.of(context).showSnackBar(
          SnackBar(content: Text('删除失败: ${e.toString()}')),
        );
      }
    }
    // ...